## DotNetify-LoadTester

_DotNetify-LoadTester_ is a tool for authoring and running performance testing on your dotNetify application servers. It allows you to establish thousands of concurrent SignalR connections to your dotNetify hub and write tests that emulate how your application clients interact with the server-side view models.

<d-alert info="true">

<b>This is a closed source library for Pro, Team, and Enterprise sponsors.</b> If you are one, send an email to _admin@dotnetify.net_ with your username to get your license key.  

- Pro sponsor: single developer, up to 100 client connections.
- Team sponsor: up to 10 developers, up to 1000 client connections + private email support.
- Enterprise sponsor: up to 10000 client connections + private email support.

</d-alert>

Check out the demo video on the [Scale-Out page](/core/scaleout) to see this tool in action. 

#### Installation

Add **DotNetify.LoadTester** from NuGet to your .NET Core test or console app project.

#### Basic Usage

Start by creating a new instance of **LoadTestBuilder** and configure the application server URL, the number of clients, and how each one will interact with your server-side view model:

```csharp
using DotNetify.LoadTester;
...

var builder = new LoadTestBuilder("https://my-app.io")
  .AddClient(5, (client, index) =>
  {
    client.Connect(nameof(HelloWorldVM));
  });
```

The **AddClient** method allows you to configure the behaviors of each client through the delegate argument of type `ILoadTestClientBuilder`. In the above example, all clients will attempt to connect to the _HelloWorldVM_ view model at the specified URL when the test commences. And just as the real API, you can pass connect options to the **Connect** method.

Run the load test by calling the **RunAsync** method with the run duration as its argument. You can also configure how fast the clients get added or disposed with the **SetRampUpPeriod** and **SetRampDownPeriod** methods:

```csharp
await builder
  .SetRampUpPeriod(TimeSpan.FromSeconds(30))
  .SetRampDownPeriod(TimeSpan.FromSeconds(30))
  .RunAsync(TimeSpan.FromMinutes(5));
```

The interval will default to 100 milliseconds between clients if no configuration is specified.

#### Logging

It's always a good idea to pass a logger so you can access the information generated by the test runner, such as when the clients are connecting, when they are being disposed or if there are connection errors:

```csharp
ILogger logger = LoggerFactory
  .Create(builder => builder.AddConsole())
  .CreateLogger("MyLoadTest");

await builder
  .SetLogger(logger)
  .RunAsync(TimeSpan.FromMinutes(5));
```

#### Client Dispatch

To get the clients to dispatch data following a successful connection, use the **Dispatch** method. You can specify the frequency, either once or repeating with time delay in milliseconds, and use the **Wait** method to add a delay between different dispatches:

```csharp
var builder = new LoadTestBuilder("https://my-app.io")
  .AddClient(5, (client, index) =>
  {
    client
      .Connect(nameof(HelloWorldVM))
      .Dispatch(new { Greetings = "Hello" }).Once()
      .Wait(5000)
      .Dispatch(new { Greetings = "World" }).Repeat(3, 1000);
  });
```

The **Dispatch** method has an overload that allows you to pass a callback function to build the dispatch payload at runtime:

```csharp
    client
      .Connect(nameof(HelloWorldVM))
      .Dispatch(_ => new { Time = DateTime.Now }).RepeatContinuously(1000);
```

#### Handling Server Responses

When you want to inspect the responses a client receives and perhaps perform dispatches according to those responses, use the **OnServerResponse** method:

```csharp
   client
    .Connect(nameof(EchoVM))
    .OnServerResponse((vm, response) =>
    {
      var deserializedResponse = response.As<EchoPing>();
      vm.Dispatch(new { Pong = deserializedResponse.Ping.Time });
    });
```

The method parameter is an action delegate that passes two arguments: an object of type `IClientVM` that will allow you to perform a dispatch, and the server response itself, wrapped in an object of type `ServerResponse`. You can access the raw data directly or use a convenient **As** method to deserialize the data into a strongly-typed object.

#### Client Destroy

To remove a client's connection to the view model, use the **Destroy** method provided by both the `ILoadTestClientBuilder` and the `IClientVM` types.

To receive a callback when the event occurs, use the **OnDestroyed** method of `ILoadTestClientBuilder`.

#### DotNetify.LoadTester.Profiles

This extension to DotNetify.LoadTester provides a command-line tool for dotNetify sponsors to perform load tests on a dotNetify application server under common types of workloads.

For instructions on how to run, visit the GitHub repo at https://github.com/dsuryd/dotNetify-LoadTester.Profiles. Available workload profiles are:

<b>Echo</b>
<br/>
Continuous back and forth communication between the client and the server. The server sends a message to the client and waits for the response before sending the next message. Each client is served by its own view model instance. The message payload contains a sequence number and timestamp to allow the test to detect undelivered messages and measure the average message latency.

<b>Shared Echo</b>
<br/>
This profile is similar to **Echo**, but all clients sharing the same view model instance. The view model uses the connection ID from `IConnectionContext` to differentiate the clients.

<b>Broadcast</b>
<br/>
The server pushes updates to all clients at regular intervals. A single multicast view model instance is used. The message payload contains a sequence number and timestamp to allow the test to detect undelivered messages and measure the average interval between updates.

<b>Chat Room</b>
<br/>
This profile models chat rooms where clients are sending and receiving messages with each other and within groups. The clients within a group are configured into three types:

- Chatty posters (10%): send messages every 11 seconds.
- Casual posters (20%): send messages every 59 seconds.
- Lurkers (70%): only receive messages.

The message payload contains a sequence number and timestamp to allow the test to detect for undelivered messages and measure the average message latency.
